# This is the jack language compilation engine

import re


def compile_file(file):
    """
    Compile a given file or a whole directory.
    :param : string
                 A file name or directory name.
    :return:
    """
    import os
    if os.path.isdir(file):
        for name in os.listdir(file):
            file_path = os.path.join(file, name)
            compile_file(file_path)
    else:
        _compile_file(file)

    return


def _compile_file(file_path):
    """
    Compile a single file
    :param file_path: string
    :return:
    """
    if not file_path.endswith('.xml'):
        return

    with open(file_path) as f:
        tokens = f.readlines()
        # Ignore the '<tokens>' signature
        compiler = CompilationEngine(tokens[1:-1])
        result = compiler.get_result()

    # Write the result into .xml file
    with open(file_path[0:file_path.find('.') - 1] + '.xml', 'w') as output:
        result = '\n'.join(result)
        output.write(result)
    return


class CompilationEngine(object):

    SUBROUTINE_TYPE = ['function', 'method', 'constructor']
    CLASS_VAR_TYPE = ['static', 'field']
    VAR_TYPE = ['int', 'char', 'boolean']
    PRIMITIVE_RETURN_TYPE = ['int', 'char', 'boolean', 'void']
    STATEMENTS_TYPES = ['let', 'do', 'while', 'if', 'return']
    UNARY_OP = ['-', '~']
    OPS = ['+', '-', '*', '/', '&amp;', '|', '&lt;', '&gt;', '=']
    IF_STATEMENTS = ['if', 'else']
    KEYWORD_CONST = ['true', 'false', 'null', 'this']
    TERM_TYPE = ['identifier', 'keyword', 'integerConstant', 'stringConstant']
    _TAG_CLEANER = re.compile('<.*?>')

    def __init__(self, input_tokens):
        """
        :param input_tokens: A list of strings, each of which stands for a token
                            generated by a tokenizer
        """
        self.token_list = input_tokens
        self.num_tokens_left = len(input_tokens)
        self.current_token = 0
        self.compilation_result = []
    
    def compile_class(self):
        """
        Compile a whole class. This method will be invoked
        when a 'class' keyword is seen by the engine.
        """
     
        if self._get_the_token() != 'class':
            raise ValueError('Missing keyword <class>')
            
        self.compilation_result.append('<class>')
        
        # Compile class head.
        self._eat('class')
        if self._get_the_token_type() != 'identifier':
            raise ValueError('An identifier must be followed by a class declaration')
        self._eat(self._get_the_token())
        self._eat('{')

        # Compile the class body recursively
        while True:
            the_token = self._get_the_token()

            if the_token in self.CLASS_VAR_TYPE:
                self.compile_class_var_dec()

            elif the_token in self.SUBROUTINE_TYPE:
                self.compile_subroutine_dec()

            else:
                break
        self._eat('}')
        self.compilation_result.append('</class>')

        return self.compilation_result

    def compile_class_var_dec(self):
        """
        Compile a static or field variable declaration
        """
        # Compile the head of class variable declaration.
        self.compilation_result.append('<classVarDec>')
        self._eat(self._get_the_token())
        if self._get_the_token_type() == 'identifier' or self._get_the_token() in self.VAR_TYPE:
            self._eat(self._get_the_token())
        else:
            raise ValueError('Variable type should be specified')
        
        # Compile the variable(s) declared.
        while self._get_the_token() != ';':
            if self._get_the_token_type() == 'identifier':
                self._eat(self._get_the_token())
            else:
                raise ValueError('Illegal variable name!')
            
            if self._get_the_token() == ',':
                self._eat(',')
            elif self._get_the_token() != ';':
                raise ValueError('Variable names must separated by comma')
        self._eat(';')
        
        self.compilation_result.append('</classVarDec>')
        
        return
        
    def compile_subroutine_dec(self):
        """
        Compile a method/function/constructor declaration in a class.
        """
        self.compilation_result.append('<subroutineDec>')
        self._eat(self._get_the_token())
        
        # Then token after the subroutine signature should be
        # the return type of the subroutine
        if (self._get_the_token() in self.PRIMITIVE_RETURN_TYPE) or (self._get_the_token_type() == 'identifier'):
            self._eat(self._get_the_token())
        
        else:
            raise ValueError('Illegal return type!')
        
        if self._get_the_token_type() == 'identifier':
            self._eat(self._get_the_token())
        else:
            raise ValueError('Illegal function name!')
        
        # Compile the subroutine's parameters
        # and the parenthesis.
        self._eat('(')
        self.compile_parameter_list()
        self._eat(')')
        
        # Compile the subroutine's body
        # and the wrapping curly brackets.
        self.compile_subroutine_body()
        self.compilation_result.append('</subroutineDec>')

        return
        
    def compile_subroutine_body(self):
        """
        Compile a subroutine's body.
        A subroutine body each consists of a sequence of variable declaration or a sequence
        of statements
        """
        self.compilation_result.append('<subroutineBody>')
        self._eat('{')

        # Variable declaration in a function.

        while self._get_the_token() == 'var':
            self.compilation_result.append('<varDec>')
            self.compile_var_dec()
            self.compilation_result.append('</varDec>')
        
        if self._get_the_token() not in self.STATEMENTS_TYPES:
            raise ValueError('There is no statement in this subroutine!')
        self.compile_statements()
        
        self._eat('}')
        self.compilation_result.append('</subroutineBody>')
        
        return

    def compile_parameter_list(self):
        """
        Compile a (list of) parameters.
        """
        self.compilation_result.append('<parameterList>')
        
        # Compile 0 or more comma separated parameters
        while self._get_the_token() != ')':
            if self._get_the_token() in self.VAR_TYPE or self._get_the_token_type() == 'identifier':
                self._eat(self._get_the_token())
            else:
                raise ValueError('Illegal parameter type.')

            if self._get_the_token_type() == 'identifier':
                self._eat(self._get_the_token())
            else:
                raise ValueError('Illegal parameter name!')
            
            if self._get_the_token() == ',':
                self._eat(',')
            elif self._get_the_token() != ')':
                raise ValueError('Parameters must be separated by commas!')
        
        self.compilation_result.append('</parameterList>')
        
        return
    
    def compile_var_dec(self):
        """
        Compile the variable declaration in a method/function.
        """
        self._eat('var')
        
        if self._get_the_token() in self.VAR_TYPE or self._get_the_token_type() == 'identifier':
            self._eat(self._get_the_token())
        else:
            raise ValueError('Illegal variable type!')
        while self._get_the_token() != ';':
            if self._get_the_token_type() != 'identifier':
                raise ValueError('Illegal variable name!')
            else:
                self._eat(self._get_the_token())
            if self._get_the_token() == ',':
                self._eat(',')
        
        self._eat(';')
        
        return
        
    def compile_statements(self):
        """
        Compile a sequence of statements, not including the enclosing curly brackets.
        """
        self.compilation_result.append('<statements>')
        while self._get_the_token() in self.STATEMENTS_TYPES:
            the_token = self._get_the_token()
            if the_token == 'do':
                self.compile_do()
            if the_token == 'let':
                self.compile_let()
            if the_token == 'while':
                self.compile_while()
            if the_token == 'if':
                self.compile_if()
            if the_token == 'return':
                self.compile_return()
        self.compilation_result.append('</statements>')
            
        return
        
    def compile_do(self):
        """
        Compiles a do statement.
        """
        self.compilation_result.append('<doStatement>')
        self._eat('do')
        
        self._eat(self._get_the_token())
        if self._get_the_token() == '.':
            self._eat('.')
            self._eat(self._get_the_token())

        self._eat('(')
        self.compile_expression_list()
        self._eat(')')
        self._eat(';')
        self.compilation_result.append('</doStatement>')

        return
        
    def compile_let(self):
        """
        Compile a let statement.
        """
        self.compilation_result.append('<letStatement>')
        self._eat('let')
        if self._get_the_token_type() == 'identifier':
            self._eat(self._get_the_token())

        # May be an array element assignment
        if self._get_the_token() == '[':
            self._eat('[')
            self.compile_expression()
            self._eat(']')

        self._eat('=')
        self.compile_expression()
        self._eat(';')
        self.compilation_result.append('</letStatement>')

        return
        
    def compile_while(self):
        """
        Compile a while statement.
        """
        self.compilation_result.append('<whileStatement>')
        self._eat('while')
        self._eat('(')
        self.compile_expression()
        self._eat(')')
        self._eat('{')
        self.compile_statements()
        self._eat('}')
        self.compilation_result.append('</whileStatement>')

        return
    
    def compile_return(self):
        """
        Compile a return statement.
        """
        self.compilation_result.append('<returnStatement>')
        self._eat('return')
        if self._get_the_token() != ';':
            self.compile_expression()

        self._eat(';')
        self.compilation_result.append('</returnStatement>')

        return
    
    def compile_if(self):
        """
        Compile a if statement.
        """
        self.compilation_result.append('<ifStatement>')
        for clause in self.IF_STATEMENTS:
            if self._get_the_token() == clause:
                self._eat(self._get_the_token())

                # 'if' clause has expression conditions
                if clause == 'if':
                    self._eat('(')
                    self.compile_expression()
                    self._eat(')')

                self._eat('{')
                self.compile_statements()
                self._eat('}')
        self.compilation_result.append('</ifStatement>')
        return

    def compile_expression(self):
        """
        Compile an expression.
        """
        self.compilation_result.append('<expression>')
        while True:
            self.compile_term()
            if self._get_the_token() in self.OPS:
                self._eat(self._get_the_token())
            else:
                break

        self.compilation_result.append('</expression>')
        return

    def compile_term(self):
        """
        Compile a term.
        """
        the_token = self._get_the_token()
        the_type = self._get_the_token_type()
        self.compilation_result.append('<term>')

        if (the_type in ['identifier', 'integerConstant', 'stringConstant'] or
                the_token in self.KEYWORD_CONST):

            self._eat(the_token)

            # May be addressing an array element
            if self._get_the_token() == '[':
                self._eat('[')
                self.compile_expression()
                self._eat(']')

            # May be a subroutine call
            elif self._get_the_token() == '(':
                self._eat('(')
                self.compile_expression_list()
                self._eat(')')
            elif self._get_the_token() == '.':
                self._eat('.')
                self._eat(self._get_the_token())
                self._eat('(')
                self.compile_expression_list()
                self._eat(')')

        elif the_token == '(':
            self._eat('(')
            self.compile_expression()
            self._eat(')')

        if the_token in self.UNARY_OP:
            self._eat(the_token)
            self.compile_term()

        self.compilation_result.append('</term>')
        return

    def compile_expression_list(self):
        """
        Compile a list of expressions.
        Typically in a subroutine call.
        """
        self.compilation_result.append('<expressionList>')
        while self._get_the_token() != ')':
            self.compile_expression()
            if self._get_the_token() == ',':
                self._eat(',')
        self.compilation_result.append('</expressionList>')
        return
        
    def _eat(self, token):
        """
        :param token: String
                      The token to advance over.
        Output the given token and advance the token list.

        Raise Value Error if the given token does not match
        the current token.
        """
        print(self._get_the_token())
        if self._get_the_token() != token:
            raise ValueError('No {0} to eat'.format(token))

        raw_token = self.token_list[self.current_token]
        self.compilation_result.append(raw_token.strip('\n'))
        self.current_token += 1
        self.num_tokens_left -= 1
        return

    def _get_the_token_type(self):
        """
        Return the current the token
        :return: String
                 The current token.
        """

        raw_token = self.token_list[self.current_token].strip()
        raw_token = raw_token.split()
        return raw_token[0].strip('<>')
    
    def _get_the_token(self):
        """
        Get the current token.
        :return: The token with tag stripped.
        """
        raw_token = self.token_list[self.current_token]
        raw_token = re.sub(self._TAG_CLEANER, '', raw_token)

        return raw_token.strip()

    def get_result(self):
        """
        Return the compiled result.
        :return: List of strings of compiled tokens
        """
        self.compile_class()
        return self.compilation_result


if __name__ == '__main__':
    import sys
    file_name = sys.argv[1]
    compile_file(file_name)
